{"ast":null,"code":"'use strict';\n\nvar Lexer = require('./lexer'),\n    Expression = require('./expressions').Expression,\n    Fraction = require('./fractions'),\n    Equation = require('./equations');\n\nvar Parser = function () {\n  this.lexer = new Lexer();\n  this.current_token = null;\n  /**\n   * Base-grammar:\n   *\n   * expr   -> expr + term\n   *        | expr - term\n   *        | - term\n   *        | term\n   *\n   * term   -> term * factor\n   *        | term factor\n   *        | term / factor\n   *        | term ^ factor\n   *        | factor\n   *\n   * factor -> (expr)\n   *        | num\n   *        | id\n   *\n   * ===============================\n   *\n   * Grammar without left recursion -> the grammar actually used\n   *\n   * eqn         -> expr = expr\n   * expr        -> term expr_rest\n   * expr_rest   -> + term expr_rest\n   *             | - term expr_rest\n   *             | ε\n   *\n   * term        -> factor term_rest\n   * term_rest   -> * term term_rest\n   *             |   term term_rest\n   *             | ^ term term_rest\n   *             | / term term_rest\n   *             | ε\n   *\n   * factor      -> (expr)\n   *             | num\n   *             | id\n   *\n   **/\n}; // Updates the current token to the next input token \n\n\nParser.prototype.update = function () {\n  this.current_token = this.lexer.token();\n}; // Returns true if the current token matches the keyword\n\n\nParser.prototype.match = function (keyword) {\n  if (this.current_token === null) return keyword === 'epsilon';\n\n  switch (keyword) {\n    case 'plus':\n      return this.current_token.type === 'OPERATOR' && this.current_token.value === 'PLUS';\n\n    case 'minus':\n      return this.current_token.type === 'OPERATOR' && this.current_token.value === 'MINUS';\n\n    case 'multiply':\n      return this.current_token.type === 'OPERATOR' && this.current_token.value === 'MULTIPLY';\n\n    case 'power':\n      return this.current_token.type === 'OPERATOR' && this.current_token.value === 'POWER';\n\n    case 'divide':\n      return this.current_token.type === 'OPERATOR' && this.current_token.value === 'DIVIDE';\n\n    case 'equal':\n      return this.current_token.type === 'OPERATOR' && this.current_token.value === 'EQUALS';\n\n    case 'lparen':\n      return this.current_token.type === 'PAREN' && this.current_token.value === 'L_PAREN';\n\n    case 'rparen':\n      return this.current_token.type === 'PAREN' && this.current_token.value === 'R_PAREN';\n\n    case 'num':\n      return this.current_token.type === 'NUMBER';\n\n    case 'id':\n      return this.current_token.type === 'IDENTIFIER';\n\n    default:\n      return false;\n  }\n};\n/*\n    Initializes the parser internals and the lexer.\n    The input is then parsed according to the grammar described in the\n    header comment. The parsing process constructs a abstract syntax tree\n    using the classes the algebra.js library provides\n*/\n\n\nParser.prototype.parse = function (input) {\n  //pass the input to the lexer\n  this.lexer.input(input);\n  this.update();\n  return this.parseEqn();\n};\n\nParser.prototype.parseEqn = function () {\n  var ex1 = this.parseExpr();\n\n  if (this.match('equal')) {\n    this.update();\n    var ex2 = this.parseExpr();\n    return new Equation(ex1, ex2);\n  } else if (this.match('epsilon')) {\n    return ex1;\n  } else {\n    throw new SyntaxError('Unbalanced Parenthesis');\n  }\n};\n\nParser.prototype.parseExpr = function () {\n  var term = this.parseTerm();\n  return this.parseExprRest(term);\n};\n\nParser.prototype.parseExprRest = function (term) {\n  if (this.match('plus')) {\n    this.update();\n    var plusterm = this.parseTerm();\n    if (term === undefined || plusterm === undefined) throw new SyntaxError('Missing operand');\n    return this.parseExprRest(term.add(plusterm));\n  } else if (this.match('minus')) {\n    this.update();\n    var minusterm = this.parseTerm(); //This case is entered when a negative number is parsed e.g. x = -4\n\n    if (term === undefined) {\n      return this.parseExprRest(minusterm.multiply(-1));\n    } else {\n      return this.parseExprRest(term.subtract(minusterm));\n    }\n  } else {\n    return term;\n  }\n};\n\nParser.prototype.parseTerm = function () {\n  var factor = this.parseFactor();\n  return this.parseTermRest(factor);\n};\n\nParser.prototype.parseTermRest = function (factor) {\n  if (this.match('multiply')) {\n    this.update();\n    var mulfactor = this.parseFactor();\n    return factor.multiply(this.parseTermRest(mulfactor));\n  } else if (this.match('power')) {\n    this.update();\n    var powfactor = this.parseFactor(); //WORKAROUND: algebra.js only allows integers and fractions for raising\n\n    return this.parseTermRest(factor.pow(parseInt(powfactor.toString())));\n  } else if (this.match('divide')) {\n    this.update();\n    var devfactor = this.parseFactor(); //WORKAROUND: algebra.js only allows integers and fractions for division\n\n    return this.parseTermRest(factor.divide(this.convertToFraction(devfactor)));\n  } else if (this.match('epsilon')) {\n    return factor;\n  } else {\n    //a missing operator between terms is treated like a multiplier\n    var mulfactor2 = this.parseFactor();\n\n    if (mulfactor2 === undefined) {\n      return factor;\n    } else {\n      return factor.multiply(this.parseTermRest(mulfactor2));\n    }\n  }\n};\n/**\n * Is used to convert expressions to fractions, as dividing by expressions is not possible\n**/\n\n\nParser.prototype.convertToFraction = function (expression) {\n  if (expression.terms.length > 0) {\n    throw new TypeError('Invalid Argument (' + expression.toString() + '): Divisor must be of type Integer or Fraction.');\n  } else {\n    var c = expression.constants[0];\n    return new Fraction(c.numer, c.denom);\n  }\n};\n\nParser.prototype.parseFactor = function () {\n  if (this.match('num')) {\n    var num = this.parseNumber();\n    this.update();\n    return num;\n  } else if (this.match('id')) {\n    var id = new Expression(this.current_token.value);\n    this.update();\n    return id;\n  } else if (this.match('lparen')) {\n    this.update();\n    var expr = this.parseExpr();\n\n    if (this.match('rparen')) {\n      this.update();\n      return expr;\n    } else {\n      throw new SyntaxError('Unbalanced Parenthesis');\n    }\n  } else {\n    return undefined;\n  }\n}; // Converts a number token - integer or decimal - to an expression\n\n\nParser.prototype.parseNumber = function () {\n  //Integer conversion\n  if (parseInt(this.current_token.value) == this.current_token.value) {\n    return new Expression(parseInt(this.current_token.value));\n  } else {\n    //Split the decimal number to integer and decimal parts\n    var splits = this.current_token.value.split('.'); //count the digits of the decimal part\n\n    var decimals = splits[1].length; //determine the multiplication factor\n\n    var factor = Math.pow(10, decimals);\n    var float_op = parseFloat(this.current_token.value); //multiply the float with the factor and divide it again afterwards \n    //to create a valid expression object\n\n    return new Expression(parseInt(float_op * factor)).divide(factor);\n  }\n};\n\nmodule.exports = Parser;","map":{"version":3,"sources":["/Users/dollina/Desktop/Project/bioinfojs/node_modules/algebra.js/src/parser.js"],"names":["Lexer","require","Expression","Fraction","Equation","Parser","lexer","current_token","prototype","update","token","match","keyword","type","value","parse","input","parseEqn","ex1","parseExpr","ex2","SyntaxError","term","parseTerm","parseExprRest","plusterm","undefined","add","minusterm","multiply","subtract","factor","parseFactor","parseTermRest","mulfactor","powfactor","pow","parseInt","toString","devfactor","divide","convertToFraction","mulfactor2","expression","terms","length","TypeError","c","constants","numer","denom","num","parseNumber","id","expr","splits","split","decimals","Math","float_op","parseFloat","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n\nvar Lexer = require('./lexer'),\n    Expression = require('./expressions').Expression,\n    Fraction = require('./fractions'),\n    Equation = require('./equations');\n\nvar Parser = function() {\n    this.lexer = new Lexer();\n    this.current_token = null;\n\n    /**\n     * Base-grammar:\n     *\n     * expr   -> expr + term\n     *        | expr - term\n     *        | - term\n     *        | term\n     *\n     * term   -> term * factor\n     *        | term factor\n     *        | term / factor\n     *        | term ^ factor\n     *        | factor\n     *\n     * factor -> (expr)\n     *        | num\n     *        | id\n     *\n     * ===============================\n     *\n     * Grammar without left recursion -> the grammar actually used\n     *\n     * eqn         -> expr = expr\n     * expr        -> term expr_rest\n     * expr_rest   -> + term expr_rest\n     *             | - term expr_rest\n     *             | ε\n     *\n     * term        -> factor term_rest\n     * term_rest   -> * term term_rest\n     *             |   term term_rest\n     *             | ^ term term_rest\n     *             | / term term_rest\n     *             | ε\n     *\n     * factor      -> (expr)\n     *             | num\n     *             | id\n     *\n     **/\n};\n\n// Updates the current token to the next input token \nParser.prototype.update = function() {\n    this.current_token = this.lexer.token();\n};\n\n// Returns true if the current token matches the keyword\nParser.prototype.match = function(keyword) {\n    if (this.current_token === null) return keyword === 'epsilon';\n\n    switch (keyword) {\n        case 'plus':\n            return ((this.current_token.type === 'OPERATOR') && (this.current_token.value === 'PLUS'));\n        case 'minus':\n            return ((this.current_token.type === 'OPERATOR') && (this.current_token.value === 'MINUS'));\n        case 'multiply':\n            return ((this.current_token.type === 'OPERATOR') && (this.current_token.value === 'MULTIPLY'));\n        case 'power':\n            return ((this.current_token.type === 'OPERATOR') && (this.current_token.value === 'POWER'));\n        case 'divide':\n            return ((this.current_token.type === 'OPERATOR') && (this.current_token.value === 'DIVIDE'));\n        case 'equal':\n            return ((this.current_token.type === 'OPERATOR') && (this.current_token.value === 'EQUALS'));\n        case 'lparen':\n            return ((this.current_token.type === 'PAREN') && (this.current_token.value === 'L_PAREN'));\n        case 'rparen':\n            return ((this.current_token.type === 'PAREN') && (this.current_token.value === 'R_PAREN'));\n        case 'num':\n            return (this.current_token.type === 'NUMBER');\n        case 'id':\n            return (this.current_token.type === 'IDENTIFIER');\n        default:\n            return false;\n    }\n};\n\n/*\n    Initializes the parser internals and the lexer.\n    The input is then parsed according to the grammar described in the\n    header comment. The parsing process constructs a abstract syntax tree\n    using the classes the algebra.js library provides\n*/\nParser.prototype.parse = function(input) {\n    //pass the input to the lexer\n    this.lexer.input(input);\n    this.update();\n    return this.parseEqn();\n};\n\nParser.prototype.parseEqn = function() {\n    var ex1 = this.parseExpr();\n    if (this.match('equal')) {\n        this.update();\n        var ex2 = this.parseExpr();\n        return new Equation(ex1,ex2);\n    }else if(this.match('epsilon')){\n        return ex1;\n    }else{\n        throw new SyntaxError('Unbalanced Parenthesis');\n    }\n};\n\nParser.prototype.parseExpr = function() {\n    var term = this.parseTerm();\n    return this.parseExprRest(term);\n};\n\nParser.prototype.parseExprRest = function(term) {\n    if (this.match('plus')) {\n        this.update();\n        var plusterm = this.parseTerm();\n        if(term === undefined || plusterm === undefined) throw new SyntaxError('Missing operand');\n        return this.parseExprRest(term.add(plusterm));\n    } else if (this.match('minus')) {\n        this.update();\n        var minusterm = this.parseTerm();\n        //This case is entered when a negative number is parsed e.g. x = -4\n        if (term === undefined) {\n            return this.parseExprRest(minusterm.multiply(-1));\n        } else {\n            return this.parseExprRest(term.subtract(minusterm));\n        }\n    } else {\n        return term;\n    }\n};\n\n\nParser.prototype.parseTerm = function() {\n    var factor = this.parseFactor();\n    return this.parseTermRest(factor);\n};\n\nParser.prototype.parseTermRest = function(factor) {\n    if (this.match('multiply')) {\n        this.update();\n        var mulfactor = this.parseFactor();\n        return factor.multiply(this.parseTermRest(mulfactor));\n    } else if (this.match('power')) {\n        this.update();\n        var powfactor = this.parseFactor();\n        //WORKAROUND: algebra.js only allows integers and fractions for raising\n        return this.parseTermRest(factor.pow(parseInt(powfactor.toString())));\n    } else if (this.match('divide')) {\n        this.update();\n        var devfactor = this.parseFactor();\n        //WORKAROUND: algebra.js only allows integers and fractions for division\n        return this.parseTermRest(factor.divide(this.convertToFraction(devfactor)));\n    } else if (this.match('epsilon')) {\n        return factor;\n    } else {\n        //a missing operator between terms is treated like a multiplier\n        var mulfactor2 = this.parseFactor();\n        if (mulfactor2 === undefined) {\n            return factor;\n        } else {\n            return factor.multiply(this.parseTermRest(mulfactor2));\n        }\n    }\n};\n\n/**\n * Is used to convert expressions to fractions, as dividing by expressions is not possible\n**/\nParser.prototype.convertToFraction = function(expression) {\n    if(expression.terms.length > 0){\n        throw new TypeError('Invalid Argument (' + expression.toString() + '): Divisor must be of type Integer or Fraction.');\n    }else{\n        var c = expression.constants[0];\n        return new Fraction(c.numer, c.denom);\n    }\n};\n\nParser.prototype.parseFactor = function() {\n    if (this.match('num')) {\n        var num = this.parseNumber();\n        this.update();\n        return num;\n    } else if (this.match('id')) {\n        var id = new Expression(this.current_token.value);\n        this.update();\n        return id;\n    } else if (this.match('lparen')) {\n        this.update();\n        var expr = this.parseExpr();\n        if (this.match('rparen')) {\n            this.update();\n            return expr;\n        } else {\n            throw new SyntaxError('Unbalanced Parenthesis');\n        }\n    } else {\n        return undefined;\n    }\n};\n\n// Converts a number token - integer or decimal - to an expression\nParser.prototype.parseNumber = function() {\n     //Integer conversion\n    if(parseInt(this.current_token.value) == this.current_token.value){\n        return new Expression(parseInt(this.current_token.value));      \n    }else{\n        //Split the decimal number to integer and decimal parts\n        var splits = this.current_token.value.split('.');\n        //count the digits of the decimal part\n        var decimals = splits[1].length;\n        //determine the multiplication factor\n        var factor = Math.pow(10,decimals);\n        var float_op = parseFloat(this.current_token.value);\n        //multiply the float with the factor and divide it again afterwards \n        //to create a valid expression object\n        return new Expression(parseInt(float_op * factor)).divide(factor);\n    }\n};\n\nmodule.exports = Parser;\n"]},"metadata":{},"sourceType":"script"}