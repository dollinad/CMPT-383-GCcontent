/**
 * Copyright Zendesk, Inc.
 *
 * Use of this source code is governed under the Apache License, Version 2.0
 * found at http://www.apache.org/licenses/LICENSE-2.0.
 */

import { useReducer, useEffect } from 'react';
import { getControlledValue, composeEventHandlers, KEY_CODES } from '@zendeskgarden/container-utilities';
import PropTypes from 'prop-types';

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function stateReducer(state, action) {
  switch (action.type) {
    case 'FOCUS':
      {
        if (action.onFocus) {
          if (action.payload !== action.focusedItem) {
            action.onFocus(action.payload);
          }
          return state;
        }
        return _extends({}, state, {
          focusedItem: action.payload
        });
      }
    case 'INCREMENT':
      {
        var controlledFocusedItem = getControlledValue(action.focusedItem, state.focusedItem);
        var controlledSelectedItem = getControlledValue(action.selectedItem, state.selectedItem);
        var currentItemIndex = controlledFocusedItem === undefined ? action.items.indexOf(controlledSelectedItem) : action.items.indexOf(controlledFocusedItem);
        var newFocusedItem = action.items[(currentItemIndex + 1) % action.items.length];
        if (action.onFocus) {
          action.onFocus(newFocusedItem);
          return state;
        }
        return _extends({}, state, {
          focusedItem: newFocusedItem
        });
      }
    case 'DECREMENT':
      {
        var _controlledFocusedItem = getControlledValue(action.focusedItem, state.focusedItem);
        var _controlledSelectedItem = getControlledValue(action.selectedItem, state.selectedItem);
        var _currentItemIndex = _controlledFocusedItem === undefined ? action.items.indexOf(_controlledSelectedItem) : action.items.indexOf(_controlledFocusedItem);
        var _newFocusedItem = action.items[(_currentItemIndex + action.items.length - 1) % action.items.length];
        if (action.onFocus) {
          action.onFocus(_newFocusedItem);
          return state;
        }
        return _extends({}, state, {
          focusedItem: _newFocusedItem
        });
      }
    case 'HOME':
      {
        if (action.onFocus) {
          action.onFocus(action.items[0]);
          return state;
        }
        return _extends({}, state, {
          focusedItem: action.items[0]
        });
      }
    case 'END':
      {
        if (action.onFocus) {
          action.onFocus(action.items[action.items.length - 1]);
          return state;
        }
        return _extends({}, state, {
          focusedItem: action.items[action.items.length - 1]
        });
      }
    case 'MOUSE_SELECT':
      {
        var isSelectControlled = false;
        var isFocusControlled = false;
        if (action.onSelect) {
          action.onSelect(action.payload);
          isSelectControlled = true;
        }
        if (action.onFocus) {
          action.onFocus(undefined);
          isFocusControlled = true;
        }
        if (isFocusControlled && isSelectControlled) {
          return state;
        }
        var updatedState = _extends({}, state);
        if (!isSelectControlled) {
          updatedState.selectedItem = action.payload;
        }
        if (!isFocusControlled) {
          updatedState.focusedItem = undefined;
        }
        return updatedState;
      }
    case 'KEYBOARD_SELECT':
      {
        if (action.onSelect) {
          action.onSelect(action.payload);
          return state;
        }
        return _extends({}, state, {
          selectedItem: action.payload
        });
      }
    case 'EXIT_WIDGET':
      {
        if (action.onFocus) {
          action.onFocus(undefined);
          return state;
        }
        return _extends({}, state, {
          focusedItem: undefined
        });
      }
    default:
      return state;
  }
}
function useSelection(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$direction = _ref.direction,
      direction = _ref$direction === void 0 ? 'horizontal' : _ref$direction,
      _ref$defaultFocusedIn = _ref.defaultFocusedIndex,
      defaultFocusedIndex = _ref$defaultFocusedIn === void 0 ? 0 : _ref$defaultFocusedIn,
      defaultSelectedIndex = _ref.defaultSelectedIndex,
      rtl = _ref.rtl,
      selectedItem = _ref.selectedItem,
      focusedItem = _ref.focusedItem,
      onSelect = _ref.onSelect,
      onFocus = _ref.onFocus;
  var refs = [];
  var items = [];
  var _useReducer = useReducer(stateReducer, {
    selectedItem: selectedItem,
    focusedItem: focusedItem
  }),
      state = _useReducer[0],
      dispatch = _useReducer[1];
  var controlledFocusedItem = getControlledValue(focusedItem, state.focusedItem);
  var controlledSelectedItem = getControlledValue(selectedItem, state.selectedItem);
  useEffect(function () {
    if (controlledFocusedItem !== undefined) {
      var focusedIndex = items.indexOf(controlledFocusedItem);
      refs[focusedIndex] && refs[focusedIndex].current.focus();
    }
  }, [controlledFocusedItem]);
  useEffect(function () {
    if (selectedItem === undefined && defaultSelectedIndex !== undefined) {
      dispatch({
        type: 'KEYBOARD_SELECT',
        payload: items[defaultSelectedIndex],
        onSelect: onSelect
      });
    }
  }, []);
  var getContainerProps = function getContainerProps(_temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        _ref2$role = _ref2.role,
        role = _ref2$role === void 0 ? 'listbox' : _ref2$role,
        other = _objectWithoutPropertiesLoose(_ref2, ["role"]);
    return _extends({
      role: role,
      'data-garden-container-id': 'containers.selection',
      'data-garden-container-version': '1.3.6'
    }, other);
  };
  var getItemProps = function getItemProps(_temp3, propGetterName) {
    var _extends2;
    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        _ref3$selectedAriaKey = _ref3.selectedAriaKey,
        selectedAriaKey = _ref3$selectedAriaKey === void 0 ? 'aria-selected' : _ref3$selectedAriaKey,
        _ref3$role = _ref3.role,
        role = _ref3$role === void 0 ? 'option' : _ref3$role,
        onFocusCallback = _ref3.onFocus,
        onKeyDown = _ref3.onKeyDown,
        onClick = _ref3.onClick,
        item = _ref3.item,
        focusRef = _ref3.focusRef,
        _ref3$refKey = _ref3.refKey,
        refKey = _ref3$refKey === void 0 ? 'ref' : _ref3$refKey,
        other = _objectWithoutPropertiesLoose(_ref3, ["selectedAriaKey", "role", "onFocus", "onKeyDown", "onClick", "item", "focusRef", "refKey"]);
    if (propGetterName === void 0) {
      propGetterName = 'getItemProps';
    }
    if (item === undefined) {
      throw new Error("Accessibility Error: You must provide an \"item\" option to \"" + propGetterName + "()\"");
    }
    if (focusRef === undefined) {
      throw new Error("Accessibility Error: You must provide a \"focusRef\" option to \"" + propGetterName + "()\"");
    }
    refs.push(focusRef);
    items.push(item);
    var isSelected = controlledSelectedItem === item;
    var isFocused = controlledFocusedItem === undefined ? isSelected : controlledFocusedItem === item;
    var tabIndex = isFocused || controlledSelectedItem === undefined && controlledFocusedItem === undefined && items.indexOf(item) === defaultFocusedIndex ? 0 : -1;
    var verticalDirection = direction === 'vertical' || direction === 'both';
    var horizontalDirection = direction === 'horizontal' || direction === 'both';
    return _extends((_extends2 = {
      role: role,
      tabIndex: tabIndex
    }, _extends2[selectedAriaKey] = selectedAriaKey ? isSelected : undefined, _extends2[refKey] = focusRef, _extends2.onFocus = composeEventHandlers(onFocusCallback, function () {
      dispatch({
        type: 'FOCUS',
        payload: item,
        focusedItem: focusedItem,
        onFocus: onFocus
      });
    }), _extends2.onBlur = function onBlur(e) {
      if (e.target.tabIndex === 0) {
        dispatch({
          type: 'EXIT_WIDGET',
          onFocus: onFocus
        });
      }
    }, _extends2.onClick = composeEventHandlers(onClick, function () {
      dispatch({
        type: 'MOUSE_SELECT',
        payload: item,
        onSelect: onSelect,
        onFocus: onFocus
      });
    }), _extends2.onKeyDown = composeEventHandlers(onKeyDown, function (e) {
      if (e.keyCode === KEY_CODES.UP && verticalDirection || e.keyCode === KEY_CODES.LEFT && horizontalDirection) {
        if (rtl && !verticalDirection) {
          dispatch({
            type: 'INCREMENT',
            items: items,
            focusedItem: focusedItem,
            selectedItem: selectedItem,
            onFocus: onFocus
          });
        } else {
          dispatch({
            type: 'DECREMENT',
            items: items,
            focusedItem: focusedItem,
            selectedItem: selectedItem,
            onFocus: onFocus
          });
        }
        e.preventDefault();
      } else if (e.keyCode === KEY_CODES.DOWN && verticalDirection || e.keyCode === KEY_CODES.RIGHT && horizontalDirection) {
        if (rtl && !verticalDirection) {
          dispatch({
            type: 'DECREMENT',
            items: items,
            focusedItem: focusedItem,
            selectedItem: selectedItem,
            onFocus: onFocus
          });
        } else {
          dispatch({
            type: 'INCREMENT',
            items: items,
            focusedItem: focusedItem,
            selectedItem: selectedItem,
            onFocus: onFocus
          });
        }
        e.preventDefault();
      } else if (e.keyCode === KEY_CODES.HOME) {
        dispatch({
          type: 'HOME',
          items: items,
          onFocus: onFocus
        });
        e.preventDefault();
      } else if (e.keyCode === KEY_CODES.END) {
        dispatch({
          type: 'END',
          items: items,
          onFocus: onFocus
        });
        e.preventDefault();
      } else if (e.keyCode === KEY_CODES.SPACE || e.keyCode === KEY_CODES.ENTER) {
        dispatch({
          type: 'KEYBOARD_SELECT',
          payload: item,
          onSelect: onSelect
        });
        e.preventDefault();
      }
    }), _extends2), other);
  };
  return {
    focusedItem: controlledFocusedItem,
    selectedItem: controlledSelectedItem,
    getItemProps: getItemProps,
    getContainerProps: getContainerProps
  };
}

var SelectionContainer = function SelectionContainer(_ref) {
  var children = _ref.children,
      _ref$render = _ref.render,
      render = _ref$render === void 0 ? children : _ref$render,
      options = _objectWithoutPropertiesLoose(_ref, ["children", "render"]);
  return render(useSelection(options));
};
SelectionContainer.propTypes = {
  children: PropTypes.func,
  render: PropTypes.func,
  rtl: PropTypes.bool,
  direction: PropTypes.oneOf(['horizontal', 'vertical', 'both']),
  defaultFocusedIndex: PropTypes.number,
  focusedItem: PropTypes.any,
  selectedItem: PropTypes.any,
  onSelect: PropTypes.func,
  onFocus: PropTypes.func
};

export { SelectionContainer, useSelection };
